## Тут про файловую систему

### Table of content

### Table of content
1. [Базовая файловая система System V](#base)
2. [Файловая система BSD UNIX(FFS)](#unix)
3. [Индексный дескриптор](#inode)
4. [Драйвера устройств](#drivers)

## Базовая файловая система System V<a name="base"></a>

Каждый жесткий диск состоит из одной или нескольких логических частей, называемых разделами (partitions). Расположение и размер определяются при форматировании диска.
Диск MBR может состоять из четырех разделов, каждый из которых содержит свою файловую систему. 
Файловая система s5fs занимает раздел диска и состоит из трех основных компонентов.

1. Суперблок (superblock). Содержит общую информацию о файловой системе, например, об ее архитектуре, общем числе блоков и индексных дескрипторов, или метаданных (inode).

2. Массив индексных дескрипторов (ilist). Содержит метаданные всех файлов файловой системы. **Индексный дескриптор** содержит статусную информацию о файле и указывает на расположение данных этого файла. Ядро обращается к inode по индексу в массиве ilist. Один inode является корневым (root) inode файловой системы, через него обеспечивается доступ к структуре каталогов и файлов после монтирования файловой системы. **Размер массива ilist является фиксированным и задается при создании файловой системы**. Таким образом, файловая система s5fs имеет ограничение по числу файлов, которые могут храниться в ней, независимо от размера этих файлов.

3. Блоки хранения данных. Данные обычных файлов и каталогов хранятся в блоках. Обработка файла осуществляется через inode, содержащего ссылки на блоки данных. Блоки хранения данных занимают большую часть дискового раздела, и их число определяет максимальный суммарный объем файлов данной файловой системы. Размер блока кратен 512 байтам, например файловая система S51K SCO UNIX использует размер блока в 1 Кбайт.

Величина блоков может быть: 1024, 2048, 4096. Если мы планируем хранить очень большие файлы, имеет смысл использовать 4096. Для большого количества маленьких файлов которые часто меняются, лучше использоваить 1024.

Если мы перемножим количество блоков на размер одного блока, мы получим размер нашего диска.

### Файловая система BSD UNIX(FFS)<a name="unix"></>

Получила улучшения, например такие как, суперблок содержит общее описание
файловой системы и располагается в начале раздела. Однако в суперблоке не
хранятся данные о свободном пространстве файловой системы, такие как массив
свободных блоков и inode. Поэтому данные суперблока остаются неизменными на
протяжении вего времени существования файловой системы. Поскольку данные
суперблока важны для работы всей файловой системы, он дублируется для повышения надежности.

Организация файловой системы предусматривает логическое деление дискового
раздела на одну или несколько групп цилиндров (cylinder group). Группа цилиндров представляет собой несколько последовательных цилиндров. Каждая группа цилиднров содержит управляющую информацию, включающую резервную копию суперблока, массив inode, данные о свободных блоках и итоговую информацию об использовании дисковых блоков в группе.

Информация о свободном пространстве в группе хранится не в виде списка свободных блоков, а в виде *битовой карты блоков*.

Кластер = блок

[Структура файловой системы
ext](https://stackoverflow.com/questions/37927728/where-are-inodes-stored-at)

[Виртуальная файловая
система](https://ru.wikipedia.org/wiki/%D0%92%D0%B8%D1%80%D1%82%D1%83%D0%B0%D0%BB%D1%8C%D0%BD%D0%B0%D1%8F_%D1%84%D0%B0%D0%B9%D0%BB%D0%BE%D0%B2%D0%B0%D1%8F_%D1%81%D0%B8%D1%81%D1%82%D0%B5%D0%BC%D0%B0#%D0%A3%D1%81%D1%82%D1%80%D0%BE%D0%B9%D1%81%D1%82%D0%B2%D0%BE_VFS)

### Индексный дескриптор

> Индексный дескриптор не содержит:
> 1. Имени файла, которые содержится в блоке хранения даннных каталога.
> 2. Содержимого файла, которое размещено в блоках хранения данных.

Заметим, что в индексном дескрипторе отсутствует информация о времени создания файла. Вместо этого inode хранит три значения времени:

1. Время последнего доступа (di_atime)
2. Время последней модификации содержимого файла (di_mtime)
3. Время последней модификации метаданных файла (di_ctime)

Таким образом, di_ctime изменяется, когда изменяется размер файла, владелец, группа, или число связей.

[Where is inodes
stored](https://unix.stackexchange.com/questions/341256/where-are-i-node-tables-stored)

### Имена файлов

Как мы уже видели, ни метаданные, ни тем более блоки хранения данных, не содержат имени файла. Има файла хранится в файлах специального типа — каталогах.

## Виртуальная файловая система

Виртуальная файловая основана на представлении метаданных файла в виде, сходном
с традиционной семантикой UNIX. Интерфейсом работы с файлами является vnode,
виртуальный файловый дескриптор.

Метаданные всех активных файлов (файлов, на которые ссылаются один или более
процессов) представлены в памяти в виде incore inode, в качестве которых в
виртуальной файловой системе выступают vnode. Структура данных vnode одинакова
для всех файлов, независимо от типа реальной файловой системы, где фактически
располагается файл. Данные vnode содержат информацию, необходимую для работы
виртуальной файловой системы, а также неизменные характеристики файла, например,
такие как тип файла.


## Монтирование файловой системы

Монтирование файловой системы производится системным вызовом mount. В качестве аргументов передается тип монтируемой файловой системы, имя каталога, к которму подключается файловая система (точка монтирования), флаги (например, доступ к файловой системе только для чтения) и дополнительные данные, конкретный вид и содержимое которых зависят от реализации реальной файловой системы. При этом произоводится поиск vnode, соответствующего файлу – точке монтирования, и проверяется, что файл является каталогом и не используется в настоящее время для монтирования других файловых систем.

## Драйвера устройств<a name="drivers"></a>

Драйвера устройств обеспечивают интерфейс между ядром UNIX и аппаратной частью компьютера. В UNIX существует большое количество драйверов. Часть из них обеспечивает доступ к физическим устойствам, например, жесткому диску, принтеру или терминалу, другие предоставляют аппаратно-независимые услуги. 

Три основные тип драйверов:

1. Символьные драйверы — обеспечивает работу с устройствами с побайтовым
доступом и обменном данными. К таким устройствам можно отнести модемы,
терминалы, принтеры, манипуляторы мышь и т.д. Доступ к таким драйверам не
включает использование **буферного кэша**, таким образом ввод и вывод как
правило не буферизируется.

2. Блочные драйверы — позволяет производить обмен данными с устройствами
фиксированными порциями (блоками). Например, для жесткого диска данные можно
адресовать и, соответственно, читать только секторами, размер которых составляет
несколько сотен байтов. Для блочных драйверов обычно используется **буферный
кэш**, который и является интерфейсом между файловой системой и устройством.
Хотя операции чтения и записи для процесса допускают обмен.

3. Драйверы низкого уровня (raw drivers) — этот тип интерфейса блочных драйверов
позволяет производить обмен данными с блочными устройствами, минуя буферный кэш.
Это, в частности означает, что устройство может быть адресовано элементами,
размер которых не совпадает с размером блока. Обмен данными происходит
независимо от файловой подсистемы и буферного кэша, что позволяет ядру
производить передачу непосредственно между пользовательским процессом и
устройством, без дополнительного уровня.

Процесс => Файловая подсистема(Ядро UNIX) => Буферный кэш(Ядро UNIX) =>
Подсистема ввода/ввывода(Ядро UNIX) => Драйвер диска => Жесткий диск

1. Процесс
> Интерфейс системных вызовов
2. Файловая подсистема(Ядро UNIX)
3. Буферный кэш(Ядро UNIX)
4. Подсистема вводы/вывода(Ядро UNIX)
> Интерфейс драйверов устройств
5. Драйвер диска
6. Жесткий диск

Не все драйвера служат для работы с физическим устройствами, такими как сетевой
адаптер, последовательный порт или монитор. Часть драйверов служит для
предоставления различных услуг ядра прикладным процессам и не имеют
непосредственного отношения к аппаратной части компьютера. Такие драйверами
называются **программными** или драйверами **псевдоустройств**. Можно привести
несколько примеров псевдоустройств и соотвествующих им программных драйверов:

1. /dev/kmem —  обеспечивает доступ к виртуальной памяти ядра. 
2. /dev/mem — обеспечивает доступ к физической памяти компьютера.

Вообще говоря, можно выделить пять основных случаев, в которых ядро обращается к
функциям драйвера:

1. Автокофигурация — обычно происходит в процессе инициализация UNIX, когда ядро
определяет, какие устройство доступны в системе.
2. Ввод/вывод — запрос на операцию ввода/вывода может быть инициирован как
прикладным процессом, так и некоторыми подсистемами ядра, например, подсистемой
управления памятью.
3. Обработка прерываний — ядро вызывает соотвествующую функцию драйвера для
обработки прерывания, поступившего от устройства (если устройство способно
генерировать прерывания).
4. Специальные запросы — ядро вызывает соответствующую функцию драйвера для
обработки специальных команд, полученных с помощью системного вызова ioctl.
5. Реинициализация/Останов. — некоторые типы аппаратных архитектур могут
требовать сброса и реинициализации устроства.

## Встраивание драйверов в ядро

Драйвер устройства является частью кода ядра операционной системы и обеспечивает
взаимодействие других подсистем UNIX с физическими или псевдоустройствами.
Существует два основных методы встраивания кода и данных драйвера в ядро
операционной системы: 

1. Перекомпиляция ядра, позволяющая статически поместить драйвер
2. Динамическая загрузка драйвера в ядро в процессе работы системы

## Блочные устройства

Драйвера блочных устройств предназначены для обслуживания перефирийного
оборудования, обеспечивающего обмен данными с помощью фрагментов фиксированной
длины, называемыми **блоками**, размер которых значительно превышает один байт.
Эти драйвера используются файловой подсистемойи и подсистемой управления
памятью.
Блочные устройства можно разделить на два типа в завимости от того, используются
ли они для хранения файловой системы или нет. Соответственно различаются и схема
доступа к этим устройствам. В последнем случае доступ к устройству
осуществляется только через специальный файл устройства, представляющий
интерфейс низкого уровня. Хотя обращение к устройствам, содержащим файловые
системы, может также осуществляться через интерфейс низкого, доступ к таким
устройствам, как правило осуществляется процессом косвенно, через запросы к
файловой системе. Например, чтение или запись обычного файла вызывает операции с
драйвером блочного устройства (жесткого диска), на котором расположена файловая
система, хранящая данный файл. В этом случае обмен данными происходит при
активном участии буферного кэша, позволяющего минимизировать число обращений
непосредственного к физическому устройству.

Операции ввода/вывода для блочного устройства могут быть вызваны рядом событий:

1. Чтением или записью в обычный файл.
2. Чтением или записью непосредственно в специальный файл устройства.
3. Операциями подсистемы управления память: страничным замещением или свопингом.

Не секрет, что операции дискового ввода/вывода являются медленными по сравнению, например, с доступом к оперативной или сверхоперативной памяти. Время чтения данных с диска и копирования тех же данных в памяти может различаться в несколько тысяч раз. Поскольку основные данные хранятся на дисковых накопителях, дисковый ввод/вывод является узким местом операционной системы. Для повышения производительности дискового ввода/вывода и, соответственно, всей системы в целом, в UNIX используется кэширование дисковых блоков в памяти.

Для этого используется выделенная область оперативной памяти, где кэшируются дисковые блоки файлов, к которым наиболее часто осуществляется доступ. Эта область памяти и связанный с ней процедурный интерфейс носят название буферного кэша, и через него проходит большинство операций файлового ввода/вывода.

## Архитектура терминального доступа

Алфавитно-цифровой терминал — последовательной устройство, и операционная
система производит обмен данными с терминало через последовательный интерфейс,
называемый *терминальной линией*. С каждой терминальной линией в UNIX
ассоциирован специальный файл символьного устройства /dev/ttyxx.

Терминальный драйверы выполняют ту же функцию, что и остальные драйверы:
управление передачей данных от/на терминалы. Однако терминалы имеют одну
особенность, связанную с тем, что они обечспечивают интерфейс пользователя с
системой.

## Псевдотерминалы

Псевдотерминалы являются специальным устройством, эмулирующим стандартную
терминальную линию.
Псевдотерминал по существу представляет собой два отдельных драйвера. Один из
них выглядет как обычный терминальный драйвер и носит название *подчиненного
устройства* (slave). Второй драйвер называется *основным* (master).






































































































































## Структура /etc/fstab

[Чтение](https://help.ubuntu.ru/wiki/fstab)

<file system> <mount point> <type> <options> <dump> <pass>

/dev/sda1       /           ext4   defaults   0      0

Узнать UUID раздела можно из вывода команды: blkid

