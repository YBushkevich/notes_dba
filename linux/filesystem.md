## Тут про файловую систему

### Table of content

### Table of content
1. [Что такое процесс](#what-process)
2. [Структура процесса](#structure)
3. [Состояние процесса](#state)
4. [Планировщик](#plan)
5. [Контекст процеса](#context)

## Базовая файловая система System V

Каждый жесткий диск состоит из одной или нескольких логических частей, называемых разделами (partitions). Расположение и размер определяются при форматировании диска.
Диск может состоять из четырех разделов, каждый из которых содержит свою файловую систему. 
Файловая система s5fs занимает раздел диска и состоит из трех основных компонентов.

1. Суперблок (superblock). Содержит общую информацию о файловой системе, например, об ее архитектуре, общем числе блоков и индексных дескрипторов, или метаданных (inode).

2. Массив индексных дескрипторов (ilist). Содержит метаданные всех файлов файловой системы. **Индексный дескриптор** содержит статусную информацию о файле и указывает на расположение данных этого файла. Ядро обращается к inode по индексу в массиве ilist. Один inode является корневым (root) inode файловой системы, через него обеспечивается доступ к структуре каталогов и файлов после монтирования файловой системы. **Размер массива ilist является фиксированным и задается при создании файловой системы**. Таким образом, файловая система s5fs имеет ограничение по числу файлов, которые могут храниться в ней, независимо от размера этих файлов.

3. Блоки хранения данных. Данные обычных файлов и каталогов хранятся в блоках. Обработка файла осуществляется через inode, содержащего ссылки на блоки данных. Блоки хранения данных занимают большую часть дискового раздела, и их число определяет максимальный суммарный объем файлов данной файловой системы. Размер блока кратен 512 байтам, например файловая система S51K SCO UNIX использует размер блока в 1 Кбайт.

Величина блоков может быть: 1024, 2048, 4096. Если мы планируем хранить очень большие файлы, имеет смысл использовать 4096. Для большого количества маленьких файлов которые часто меняются, лучше использоваить 1024.

Если мы перемножим количество блоков на размер одного блока, мы получим размер нашего диска.

### Индексный дескриптор

> Индексный дескриптор не содержит:
> 1. Имени файла, которые содержится в блоке хранения даннных каталога.
> 2. Содержимого файла, которое размещено в блоках хранения данных.

Заметим, что в индексном дескрипторе отсутствует информация о времени создания файла. Вместо этого inode хранит три значения времени:

1. Время последнего доступа (di_atime)
2. Время последней модификации содержимого файла (di_mtime)
3. Время последней модификации метаданных файла (di_ctime)

Таким образом, di_ctime изменяется, когда изменяется размер файла, владелец, группа, или число связей.

### Имена файлов

Как мы уже видели, ни метаданные, ни тем более блоки хранения данных, не содержат имени файла. Има файла хранится в файлах специального типа — каталогах.

## Монтирование файловой системы

Монтирование файловой системы производится системным вызовом mount. В качестве аргументов передается тип монтируемой файловой системы, имя каталога, к которму подключается файловая система (точка монтирования), флаги (например, доступ к файловой системе только для чтения) и дополнительные данные, конкретный вид и содержимое которых зависят от реализации реальной файловой системы. При этом произоводится поиск vnode, соответствующего фалу – точке монтирования, и проверяется, что файл является каталогом и не используется в настоящее время для монтирования других файловых систем.

## Драйвера устройств

Драйвера устройств обеспечивают интерфейс между ядром UNIX и аппаратной частью
компьютера. В UNIX существует большое количество драйверов. Часть из них
обеспечивает доступ к физическим устойствам, например, жесткому диску, принтеру
или терминалу, другие предоставляют аппаратно-независимые услуги. 

Три основные тип драйверов:

1. Символьные драйверы — обеспечивает работу с устройствами с побайтовым
доступом и обменном данными. К таким устройствам можно отнести модемы,
терминалы, принтеры, манипуляторы мышь и т.д. Доступ к таким драйверам не
включает использование **буферного кэша**, таким образом ввод и вывод как
правило не буферизируется.

2. Блочные драйверы — позволяет производить обмен данными с устройствами
фиксированными порциями (блоками). Например, для жесткого диска данные можно
адресовать и, соответственно, читать только секторами, размер которых составляет
несколько сотен байтов. Для блочных драйверов обычно используется **буферный
кэш**, который и является интерфейсом между файловой системой и устройством.
Хотя операции чтения и записи для процесса допускают обмен.

3. Драйверы низкого уровня (raw drivers) — этот тип интерфейса блочных драйверов
позволяет производить обмен данными с блочными устройствами, минуя буферный кэш.
Это, в частности означает, что устройство может быть адресовано элементами,
размер которых не совпадает с размером блока. Обмен данными происходит
независимо от файловой подсистемы и буферного кэша, что позволяет ядру
производить передачу непосредственно между пользовательским процессом и
устройством, без дополнительного уровня.

Процесс => Файловая подсистема(Ядро UNIX) => Буферный кэш(Ядро UNIX) =>
Подсистема ввода/ввывода(Ядро UNIX) => Драйвер диска => Жесткий диск

1. Процесс
> Интерфейс системных вызовов
2. Файловая подсистема(Ядро UNIX)
3. Буферный кэш(Ядро UNIX)
4. Подсистема вводы/вывода(Ядро UNIX)
> Интерфейс драйверов устройств
5. Драйвер диска
6. Жесткий диск

Не все драйвера служат для работы с физическим устройствами, такими как сетевой
адаптер, последовательный порт или монитор. Часть драйверов служит для
предоставления различных услуг ядра прикладным процессам и не имеют
непосредственного отношения к аппаратной части компьютера. Такие драйверами
называются **программными** или драйверами **псевдоустройств**. Можно привести
несколько примеров псевдоустройств и соотвествующих им программных драйверов:

1. /dev/kmem —  обеспечивает доступ к виртуальной памяти ядра. 
2. /dev/mem — обеспечивает доступ к физической памяти компьютера.

Вообще говоря, можно выделить пять основных случаев, в которых ядро обращается к
функциям драйвера:

1. Автокофигурация — обычно происходит в процессе инициализация UNIX, когда ядро
определяет, какие устройство доступны в системе.
2. Ввод/вывод — запрос на операцию ввода/вывода может быть инициирован как
прикладным процессом, так и некоторыми подсистемами ядра, например, подсистемой
управления памятью.
3. Обработка прерываний — ядро вызывает соотвествующую функцию драйвера для
обработки прерывания, поступившего от устройства (если устройство способно
генерировать прерывания).
4. Специальные запросы — ядро вызывает соответствующую функцию драйвера для
обработки специальных команд, полученных с помощью системного вызова ioctl.
5. Реинициализация/Останов. — некоторые типы аппаратных архитектур могут
требовать сброса и реинициализации устроства.






































































































## Структура /etc/fstab

[Чтение](https://help.ubuntu.ru/wiki/fstab)

<file system> <mount point> <type> <options> <dump> <pass>

/dev/sda1       /           ext4   defaults   0      0

Узнать UUID раздела можно из вывода команды: blkid

