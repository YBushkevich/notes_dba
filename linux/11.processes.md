# Понятие процесса. Демоны. Контекст процесса. PID, PPID. Состояние процесса. Команды kill, ps.

### Table of content
1. [Что такое процесс](#what-process)
2. [Структура процесса](#structure)
3. [Состояние процесса](#state)
4. [Планировщик](#plan)
5. [Контекст процеса](#context)

## Что такое процесс <a name="what-process"></a>

Процесс представляет собой исполняемый образ программы, включающий отображение в
памяти исполняемого файла, полученного в результате компиляции, стек, код и
данные библиотек, а также ряд структур данных ядра, необходимых для управления
процессом.

Вся функциональность операционной системы в конечном счете определяется
выполнением тех или иных процессов. Даже так называемые **уровни выполнения**
(run levels) представляют собой ни что иное, как удобную форму определения
группы выполняющихся процессов. Возможность терминального или сетевого доступа к
системе, различные сервисы, традиционные для Unix, — все это результат
выполнения определенных процессов. 

Ни одна программа не умеет завершаться сама. Они могут лишь попросить систему об
этом с помощью системного вызова _exit или быть завершенными системой из-за
ошибки. Даже когда возвращаешь число из main(), всё равно неявно вызывается
_exit.

Когда процессу требуется получение каких-либо услуг ядра, он делает системный
вызов, который выполняет инструкции ядра, находящиеся на привилигерованном
уровне. Несмотря на то что выполняются инструкции ядра, это происходит от имени
процесса, сделавшего системный вызов. Выполнение процесса при этом переходит в
режим ядра. Часть процессорных инструкций, например изменение регистров,
связанных с управлением памятью, могут быть выполнены только в режиме ядра.

Образ процесса в режиме задачи состоит из сегментов кода, данных, стека,
библиотек и других структур данных, к котором он может получить непосредственный
доступ. Образ процесса в режиме ядра состоит из структур данных, недоступных
процессу в режиме задачи, которые используются ядром для управления процессом.
Сюда относятся данные, диктуемые аппаратным уровнем, например состояния
регистров, таблицы для отображения памяти и т.д., а также структуры данных,
необходимые ядру для обслуживания процесса. Вообще говоря, в режиме ядра процесс
имеет доступ к любой области памяти.

## Структуры данных процесса<a name="structure"></a>

Каждый процесс представлен в системе двумя основными структурами данных — proc и
user, описанными, соответственно в файлах <sys/proc.h> и <sys/user.h>. Структура
proc содержит в себе такую информацию:

1. Состояние процесса
2. Приоритет
3. ID процесса, различные идентификаторы.

[Свопинг linux](https://www.opennet.ru/base/sys/swap_create.txt.html)

Вторая структура — user, также называемая u-area или u-block, содержит
дополнительные данные о процессе, которые требуются ядру во время выполнения
процесса.

Размер виртуальной памяти может существенно превышать размер физической за счет
использования *вторичной памяти* или *области свопинга* — дискового
пространства где могут сохраняться временно не используемые участки адресного
пространства процесс.

## Состояние процесса<a name="state"></a>

1. Процесс выполняется в режиме задачи. При этом процессором выполняются
прикладные инструкции данного процесса.(runnable)

2. Процесс выполняется в режиме ядра. При этом процессором выполняются системные
инструкции ядра операционной системы от имени процессора.

3. Процесс не выполняется, но готов к запуску, как только планировщик выберет
его (состояние runnable). Процесс находится в очереди на выполнение и обладает
всеми необходимыми ему ресурсами, кроме вычислительных.

4. Процесс находится в состоянии сна (asleep), ожидая недоступного в данный
момент ресурса, например завершения операции ввода/вывода.

5. Процесс возврщается из режима ядра в режим задачи, но ядро прерывает его и
производит переключение контекста для запуска более высокоприоритетного
процесса.

6. Процесс только что создан вызовом fork() и находится в переходном состоянии:
он существует, но не готов к запуску и не находится в состоянии сна.

7. Процесс выполнил системный вызов exit() и перешел в состояние (zombie,
defunct). Как такового процесса не существует, но остаются записи, содержащие
код возврата и временную статистику его выполнения, доступную для родительского
процесса. Это состояние является конечным в жизненном цикле процесса.


[Планировщик процессов](https://habr.com/ru/post/154609/)

[Ещё немного про процессы, создание и
выполнение](http://www.opennet.ru/docs/RUS/lnx_process/process2.html)

## Планирование выполнения процессов<a name="plan"></a>

Планировщие процессов — подсистема ядра, которая обечспечивает предоставление
процессорных ресурсов процессам, выполняющимся в операционной системе. 

*Временной квант* — максимальный временной интервал, на который процесс может
захватить процессор.

## Контекст процесса<a name="context"></a>

Каждый процесс UNIX имеет *контекст*, под которым понимается вся информация,
требуемая для описанния процесса. Эта информация сохраняется, когда выполнение
процесса приостанавливается, и восстанавливается, когда планировщик
предоставляет процессу вычислительные ресурсы. 
Контекст — вся информация, требуемая для описания процесса.

Контекст процесса состоит из нескольких частей:

1. Адресное пространство процесса в режиме задачи. Cюда входят код, данные и
стек процесса, а также другие области, например разделяемая память или код и
данные динамических библиотек. 
2. Управляющая информация. Ядро использует две основные структуры данных для
управления процессом — proc и user. Сюда же входят данные, необходимые для
отображения виртуального адресного пространства процесса в физическое.
3. Окружение процесса. Переменные окружения процесса представляют собой
строки пар вида: *переменная=значение* которые наследуются дочерним процессом от родительского и обычно хранятся в
нижней части стека. 
4. Аппаратный контекст. Сюда входит значение общих и ряда системных
регистров процессора.

Переключение между процессами, необходимое для справедливого распределения
вычислительного ресурса, по существу выражается в *переключении контекста*,
когда контекст выполнявшегося процесса запоминается, и в восстанавливается
контекст процесса, выбранного планировщиком.

Существует четыре ситуации, при которых производится переключение контекста:

1. Текущий процесс переходит в состояние сна, ожидая недоступного ресурса.
2. Текущий процесс завершает свое выполнение.
3. После пересчета приоритетов в очереди на выполнение находится более
высокоприоритетный процесс.
4. Происходит пробуждение более высокоприоритетного процесса. 

## Разное 

В UNIX проведена четкая грань между **программой** и **процессом**. Каждый
процесс в конкретный момент времени выполняет инструкции некоторой программы,
которая может быть одной и той же для нескольких процессов.





